package com.aibridge.chat.data.api

import android.util.Log
import com.aibridge.chat.config.ApiConfig
import com.aibridge.chat.utils.NetworkUtils
import com.aibridge.chat.domain.model.PortalConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.FormBody
import okhttp3.OkHttpClient
import okhttp3.Request
import com.google.gson.Gson
import java.net.UnknownHostException
import java.io.IOException
import java.net.SocketTimeoutException
import java.net.ConnectException
import java.net.URLEncoder
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PortalApiService @Inject constructor(
    private val httpClient: OkHttpClient,
    private val networkUtils: NetworkUtils,
    private val gson: Gson
) {
    companion object {
        private const val TAG = "PortalApiService"
    }

    suspend fun sendPortalChatMessage(
        username: String,
        password: String,
        userPrompt: String,
        uploadedFile: String? = null,
        portalId: String = "13",
        alternativePortalIds: List<String> = emptyList(),
        portalConfig: PortalConfig? = null,
        sessionCookie: String? = null
    ): ChatResponse = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "Sending chat message to Portal API")
            
            // ç›´æ¥ç™¼é€èŠå¤©è«‹æ±‚ï¼Œä¾è³´æ–¼å·²ç¶“å»ºç«‹çš„èªè­‰session
            // AuthApiServiceå·²ç¶“è™•ç†äº†ç™»å…¥å’Œsessionç®¡ç†
            Log.d(TAG, "Using existing authentication session for chat request")
            
            // é¦–å…ˆå˜—è©¦ä½¿ç”¨æŒ‡å®šçš„Portal ID
            val response = sendChatRequest(userPrompt, uploadedFile, portalId, portalConfig, sessionCookie)
            
            // å¦‚æœæ”¶åˆ°403éŒ¯èª¤ä¸”æœ‰æ›¿ä»£çš„Portal IDï¼Œå˜—è©¦ä½¿ç”¨å®ƒå€‘
            if (!response.success && response.message?.contains("403") == true && alternativePortalIds.isNotEmpty()) {
                Log.w(TAG, "Portal ID $portalId failed with 403, trying alternatives: $alternativePortalIds")
                
                for (alternativeId in alternativePortalIds) {
                    if (alternativeId != portalId) {
                        Log.d(TAG, "Trying alternative Portal ID: $alternativeId")
                        val alternativeResponse = sendChatRequest(userPrompt, uploadedFile, alternativeId, portalConfig, sessionCookie)
                        
                        if (alternativeResponse.success) {
                            Log.i(TAG, "Successfully used alternative Portal ID: $alternativeId")
                            return@withContext alternativeResponse
                        } else {
                            Log.w(TAG, "Alternative Portal ID $alternativeId also failed: ${alternativeResponse.message}")
                        }
                    }
                }
                
                Log.e(TAG, "All Portal IDs failed, returning original error")
            }
            
            return@withContext response
            
        } catch (e: UnknownHostException) {
            Log.e(TAG, "DNS resolution failed: ${e.message}")
            val errorMessage = networkUtils.getNetworkErrorMessage(e.message ?: "DNS resolution failed")
            ChatResponse(success = false, message = errorMessage)
        } catch (e: SocketTimeoutException) {
            Log.e(TAG, "Connection timeout: ${e.message}")
            ChatResponse(success = false, message = "é€£ç·šé€¾æ™‚ï¼šè«‹æª¢æŸ¥ç¶²è·¯ç’°å¢ƒæˆ–ç¨å¾Œé‡è©¦")
        } catch (e: ConnectException) {
            Log.e(TAG, "Connection failed: ${e.message}")
            ChatResponse(success = false, message = "é€£ç·šå¤±æ•—ï¼šç„¡æ³•é€£æ¥åˆ°Portalæœå‹™")
        } catch (e: IOException) {
            Log.e(TAG, "Network I/O error: ${e.message}")
            val errorMessage = networkUtils.getNetworkErrorMessage(e.message ?: "Network error")
            ChatResponse(success = false, message = errorMessage)
        } catch (e: Exception) {
            Log.e(TAG, "Portal chat request exception: ${e.message}", e)
            val errorMessage = networkUtils.getNetworkErrorMessage(e.message ?: "Unknown error")
            ChatResponse(success = false, message = errorMessage)
        }
    }
    
    /**
     * ç™¼é€èŠå¤©è«‹æ±‚åˆ°Portal API
     */
    private suspend fun sendChatRequest(
        userPrompt: String,
        uploadedFile: String?,
        portalId: String,
        portalConfig: PortalConfig? = null,
        sessionCookie: String? = null
    ): ChatResponse = withContext(Dispatchers.IO) {
        try {
            val chatUrl = "${ApiConfig.BACKEND_BASE_URL}${ApiConfig.CHAT_ENDPOINT}?id=$portalId&action=completion"
            
            Log.d(TAG, "Portal API URL: $chatUrl")
            Log.d(TAG, "Portal ID: $portalId")
            Log.d(TAG, "User Prompt: $userPrompt")
            Log.d(TAG, "Sending chat message to Portal API")
            Log.d(TAG, "Using existing authentication session for chat request")
            
            // ç›´æ¥æ§‹å»ºPOSTè«‹æ±‚åˆ°completionç«¯é»
            val formBodyBuilder = FormBody.Builder()
            
            // å¦‚æœæœ‰PortalConfigï¼Œä½¿ç”¨å…¶ä¸­çš„è‡ªå®šç¾©åƒæ•¸
            if (portalConfig != null && portalConfig.parameters.isNotEmpty()) {
                Log.d(TAG, "Using custom parameters from PortalConfig: ${portalConfig.parameters}")
                // æ·»åŠ æ‰€æœ‰è‡ªå®šç¾©åƒæ•¸
                for ((key, parameter) in portalConfig.parameters) {
                    Log.d(TAG, "Adding custom parameter: $key = ${parameter.value}")
                    formBodyBuilder.add(key, parameter.value)
                }
            } else {
                // ä½¿ç”¨é»˜èªåƒæ•¸
                Log.d(TAG, "Using default parameters")
                
                // æ·»åŠ ç”¨æˆ¶æç¤º
                formBodyBuilder.add("USERPROMPT", userPrompt)
                
                // æ·»åŠ ä¸Šå‚³æ–‡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
                if (!uploadedFile.isNullOrEmpty()) {
                    // å¦‚æœæœ‰æ–‡ä»¶å…§å®¹ï¼Œéœ€è¦ç·¨ç¢¼ç‚ºbase64æ ¼å¼
                    val base64Content = android.util.Base64.encodeToString(
                        uploadedFile.toByteArray(Charsets.UTF_8), 
                        android.util.Base64.NO_WRAP
                    )
                    formBodyBuilder.add("USERUPLOADFILE", "data:text/plain;base64,$base64Content")
                } else {
                    // æ·»åŠ ç©ºçš„æ–‡ä»¶å­—æ®µ
                    formBodyBuilder.add("USERUPLOADFILE", "data:application/octet-stream;base64,")
                }
            }
            
            val formBody = formBodyBuilder.build()
            
            // æ§‹å»ºPOSTè«‹æ±‚
            val requestBuilder = Request.Builder()
                .url(chatUrl)
                .post(formBody)
                .addHeader("accept", "application/json, text/javascript, */*; q=0.01")
                .addHeader("accept-language", "zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7")
                .addHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8")
                .addHeader("sec-ch-ua", "\"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"138\", \"Google Chrome\";v=\"138\"")
                .addHeader("sec-ch-ua-mobile", "?0")
                .addHeader("sec-ch-ua-platform", "\"Windows\"")
                .addHeader("sec-fetch-dest", "empty")
                .addHeader("sec-fetch-mode", "cors")
                .addHeader("sec-fetch-site", "same-origin")
                .addHeader("x-kl-kis-ajax-request", "Ajax_Request")
                .addHeader("x-requested-with", "XMLHttpRequest")
                .addHeader("Referer", "${ApiConfig.BACKEND_BASE_URL}/")
                .addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
            
            // æ·»åŠ  Session Cookie å¦‚æœå¯ç”¨
            if (!sessionCookie.isNullOrEmpty()) {
                Log.d(TAG, "Adding session cookie to POST request")
                requestBuilder.addHeader("Cookie", sessionCookie)
            }

            val request = requestBuilder.build()

            Log.d(TAG, "Making POST request to Portal API: $chatUrl")
                    formBodyBuilder.add("USERUPLOADFILE", "data:text/plain;base64,$base64Content")
                } else {
                    formBodyBuilder.add("USERUPLOADFILE", "data:application/octet-stream;base64,")
                }
            }
            
            // å˜—è©¦æå–CSRF token
            val csrfTokenPattern = Regex("""name=['"](?:_token|csrf_token|authenticity_token)['"] value=['"]([^'"]+)['"]""")
            val csrfMatch = csrfTokenPattern.find(formPageBody)
            if (csrfMatch != null) {
                val tokenValue = csrfMatch.groupValues[1]
                Log.d(TAG, "Found CSRF token: ${tokenValue.take(20)}...")
                formBodyBuilder.add("_token", tokenValue)
            }
            
            // å˜—è©¦æå–å…¶ä»–éš±è—å­—æ®µ
            val hiddenFieldPattern = Regex("""<input[^>]*type=['"]hidden['"][^>]*name=['"]([^'"]+)['"][^>]*value=['"]([^'"]*)['"][^>]*>""")
            val hiddenMatches = hiddenFieldPattern.findAll(formPageBody)
            for (match in hiddenMatches) {
                val fieldName = match.groupValues[1]
                val fieldValue = match.groupValues[2]
                
                // æ’é™¤å·²ç¶“æ·»åŠ çš„å­—æ®µ
                if (fieldName !in listOf("USERPROMPT", "USERUPLOADFILE", "_token")) {
                    Log.d(TAG, "Found hidden field: $fieldName = $fieldValue")
                    formBodyBuilder.add(fieldName, fieldValue)
                }
            }
            
            val requestBody = formBodyBuilder.build()
            
            // ç¬¬äºŒæ­¥ï¼šæäº¤è¡¨å–®
            Log.d(TAG, "Step 2: Submitting form with extracted tokens")
            val requestBuilder = Request.Builder()
                .url(chatUrl)
                .post(requestBody)
                .addHeader("accept", "application/json, text/javascript, */*; q=0.01")
                .addHeader("accept-language", "zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7")
                .addHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8")
                .addHeader("sec-ch-ua", "\"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"138\", \"Google Chrome\";v=\"138\"")
                .addHeader("sec-ch-ua-mobile", "?0")
                .addHeader("sec-ch-ua-platform", "\"Windows\"")
                .addHeader("sec-fetch-dest", "empty")
                .addHeader("sec-fetch-mode", "cors")
                .addHeader("sec-fetch-site", "same-origin")
                .addHeader("x-kl-kis-ajax-request", "Ajax_Request")
                .addHeader("x-requested-with", "XMLHttpRequest")
                .addHeader("Referer", chatUrl)
                .addHeader("Origin", ApiConfig.BACKEND_BASE_URL)
                .addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
            
            // æ·»åŠ  Session Cookie å¦‚æœå¯ç”¨
            if (!sessionCookie.isNullOrEmpty()) {
                Log.d(TAG, "Adding session cookie to POST request")
                requestBuilder.addHeader("Cookie", sessionCookie)
            }

            val request = requestBuilder.build()

            Log.d(TAG, "Making POST request to Portal API: $chatUrl")
            
            val response = httpClient.newCall(request).execute()
            
            Log.d(TAG, "Portal API Response code: ${response.code}")
            val responseBody = response.body?.string() ?: ""
            Log.d(TAG, "Portal API Response body: $responseBody")
            
            // æª¢æŸ¥é‡å®šå‘æ¨™é ­
            if (response.code == 302) {
                val location = response.header("Location")
                Log.d(TAG, "Redirect location: $location")
            }
            
            return@withContext if (response.isSuccessful) {
                Log.i(TAG, "Portal chat request successful")
                
                try {
                    // è§£æPortal APIçš„å›æ‡‰æ ¼å¼
                    val portalResponse = gson.fromJson(responseBody, PortalApiResponse::class.java)
                    
                    if (portalResponse != null && !portalResponse.completion.isNullOrEmpty()) {
                        ChatResponse(
                            success = true,
                            message = portalResponse.completion,
                            responseData = null
                        )
                    } else {
                        Log.w(TAG, "Portal response missing completion field")
                        ChatResponse(
                            success = false,
                            message = "Portalå›æ‡‰æ ¼å¼ä¸æ­£ç¢º"
                        )
                    }
                } catch (e: Exception) {
                    Log.w(TAG, "Failed to parse Portal response: ${e.message}")
                    // å¦‚æœJSONè§£æå¤±æ•—ï¼Œå˜—è©¦å°‡æ•´å€‹å›æ‡‰ä½œç‚ºæ¶ˆæ¯
                    ChatResponse(
                        success = true,
                        message = responseBody.ifEmpty { "Portalå›æ‡‰æˆåŠŸä½†å…§å®¹ç‚ºç©º" }
                    )
                }
            } else {
                Log.w(TAG, "Portal chat request failed with code: ${response.code}")
                
                // æª¢æ¸¬ 403 éŒ¯èª¤é é¢ä¸­çš„å…·é«”åŸå› 
                if (response.code == 403) {
                    // æª¢æŸ¥æ˜¯å¦ç‚º Portal ID æ¬Šé™å•é¡Œ
                    val is403ForbiddenPage = responseBody.contains("403 - Forbidden") && 
                                           responseBody.contains("Your request to the page are not authorized")
                    
                    if (is403ForbiddenPage) {
                        Log.w(TAG, "Detected 403 Forbidden - Portal ID access denied")
                        return@withContext ChatResponse(
                            success = false,
                            message = "ğŸ”’ Portalæäº¤æ¬Šé™ä¸è¶³ (Portal ID: $portalId)\n\n" +
                                     "ç•¶å‰ç”¨æˆ¶å¯ä»¥æŸ¥çœ‹æ­¤Portalï¼Œä½†æ²’æœ‰æäº¤æ¬Šé™ã€‚\n\n" +
                                     "å¯èƒ½çš„åŸå› ï¼š\n" +
                                     "â€¢ ç”¨æˆ¶æ¬Šé™ç´šåˆ¥ä¸è¶³\n" +
                                     "â€¢ Portaléœ€è¦ç‰¹æ®Šæˆæ¬Š\n" +
                                     "â€¢ ç®¡ç†å“¡å°šæœªé–‹æ”¾æ­¤Portalçš„æäº¤åŠŸèƒ½\n\n" +
                                     "ğŸ’¡ è«‹è¯ç¹«ç³»çµ±ç®¡ç†å“¡ç²å–é©ç•¶æ¬Šé™ï¼Œæˆ–å˜—è©¦ä½¿ç”¨å…¶ä»–Portalé…ç½®ã€‚",
                            errorDetails = "PORTAL_ACCESS_DENIED"
                        )
                    }
                }
                
                val errorMessage = when (response.code) {
                    302 -> "éœ€è¦é‡æ–°èªè­‰æˆ–ç™»å…¥Portalæœå‹™"
                    400 -> "è«‹æ±‚æ ¼å¼éŒ¯èª¤"
                    401 -> "èªè­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç™»å…¥ç‹€æ…‹"
                    403 -> "æ²’æœ‰æ¬Šé™è¨ªå•Portalæœå‹™ - è«‹è¯ç¹«ç®¡ç†å“¡ç²å–æ¬Šé™"
                    404 -> "Portalæœå‹™ç«¯é»ä¸å­˜åœ¨"
                    429 -> "è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œé‡è©¦"
                    500 -> "Portalä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤"
                    502, 503, 504 -> "Portalä¼ºæœå™¨æš«æ™‚ç„¡æ³•ä½¿ç”¨"
                    else -> "Portalè«‹æ±‚å¤±æ•— (HTTP ${response.code})"
                }
                
                ChatResponse(
                    success = false,
                    message = errorMessage,
                    errorDetails = responseBody
                )
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Chat request failed: ${e.message}", e)
            val errorMessage = networkUtils.getNetworkErrorMessage(e.message ?: "Unknown error")
            ChatResponse(success = false, message = errorMessage)
        }
    }
}

/**
 * Portal API å›æ‡‰æ ¼å¼
 */
data class PortalApiResponse(
    val completion: String?,
    val usage: PortalUsage?
)

data class PortalUsage(
    val promptTokens: Int = 0,
    val completionTokens: Int = 0,
    val totalTokens: Int = 0
)
